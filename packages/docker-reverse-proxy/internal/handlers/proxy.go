package handlers

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/e2b-dev/infra/packages/docker-reverse-proxy/internal/auth"
	"github.com/e2b-dev/infra/packages/docker-reverse-proxy/internal/cache"
	"github.com/e2b-dev/infra/packages/docker-reverse-proxy/internal/constants"
	"github.com/e2b-dev/infra/packages/docker-reverse-proxy/internal/utils"
	"github.com/e2b-dev/infra/packages/shared/pkg/consts"
)

func (a *APIStore) Proxy(w http.ResponseWriter, req *http.Request) {
	// Check if the request is for the correct repository
	path := req.URL.String()
	log.Printf("[DEBUG] Proxy - Handling request: %s %s", req.Method, path)

	// Validate the token by checking if the generated token is in the cache
	authHeader := req.Header.Get("Authorization")
	log.Printf("[DEBUG] Proxy - Auth header: %s", authHeader)
	e2bToken := strings.TrimPrefix(authHeader, "Bearer ")
	token, err := a.AuthCache.Get(e2bToken)
	if err != nil {
		log.Printf("Error while getting token for %s: %s, header: %s\n", path, err, authHeader)
		utils.SetDockerUnauthorizedHeaders(w)
		return
	}

	log.Printf("[DEBUG] Proxy - Found token in cache for template ID: %s, docker token (first 10 chars): %s...", 
		token.TemplateID, token.DockerToken[:10])

	// Handle based on cloud provider
	if constants.CurrentCloudProvider == constants.GCP {
		// Set the Authorization header for the request to the real docker registry
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token.DockerToken))
		log.Printf("[DEBUG] Proxy - Set Bearer Authorization header for GCP")
		handleGCPProxy(a, w, req, path, token)
	} else if constants.CurrentCloudProvider == constants.AWS {
		// For AWS ECR, we'll handle authentication in handleAWSProxy
		log.Printf("[DEBUG] Proxy - Delegating to AWS ECR proxy handler")
		handleAWSProxy(a, w, req, path, token)
	} else {
		log.Printf("Unsupported cloud provider for path: %s\n", path)
		w.WriteHeader(http.StatusInternalServerError)
	}
}

func handleGCPProxy(a *APIStore, w http.ResponseWriter, req *http.Request, path string, token *cache.AccessTokenData) {
	// Allow access to the GCP artifact uploads.
	// The url is generated by repository and sent as a Location header from the /blobs/upload request
	// https://distribution.github.io/distribution/spec/api/#starting-an-upload
	// Other methods than PATCH require the Authorization header
	if strings.HasPrefix(path, constants.GCPArtifactUploadPrefix) {
		a.ServeHTTP(w, req)
		return
	}

	repoPrefix := "/v2/e2b/custom-envs/"
	realRepoPrefix := fmt.Sprintf("/v2/%s/%s/", consts.GCPProject, consts.DockerRegistry)
	if !strings.HasPrefix(path, repoPrefix) && !strings.HasPrefix(path, realRepoPrefix) {
		// The request shouldn't need any other endpoints, we deny access
		log.Printf("No matching route found for path: %s\n", path)

		w.WriteHeader(http.StatusForbidden)
		return
	}

	templateID := token.TemplateID

	// Uploading blobs doesn't have the template ID in the path
	if strings.HasPrefix(path, fmt.Sprintf("%spkg/blobs/uploads/", realRepoPrefix)) {
		a.ServeHTTP(w, req)

		return
	}

	pathInRepo := strings.TrimPrefix(path, repoPrefix)
	templateWithBuildID := strings.Split(strings.Split(pathInRepo, "/")[0], ":")

	// If the template ID in the path is different from the token template ID, deny access
	if templateWithBuildID[0] != templateID {
		w.WriteHeader(http.StatusForbidden)
		log.Printf("Access denied for template: %s\n", templateID)

		return
	}

	// Set the host and access token for the real docker registry
	req.URL.Path = strings.Replace(req.URL.Path, repoPrefix, realRepoPrefix, 1)

	a.ServeHTTP(w, req)
}

func handleAWSProxy(a *APIStore, w http.ResponseWriter, req *http.Request, path string, token *cache.AccessTokenData) {
	templateID := token.TemplateID
	
	// 确保 ECR 仓库存在
	err := auth.EnsureECRRepositoryExists(templateID)
	if err != nil {
		log.Printf("[ERROR] Error ensuring ECR repository exists: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(fmt.Sprintf("Failed to ensure ECR repository exists: %v", err)))
		return
	}

	log.Printf("[INFO] AWS Proxy - Request: %s %s", req.Method, req.URL.Path)
	
	// 使用缓存中的令牌，而不是每次都获取新的令牌
	req.Header.Set("Authorization", fmt.Sprintf("Basic %s", token.DockerToken))
	log.Printf("[DEBUG] AWS Proxy - Set Basic auth header for AWS ECR using cached token")
	
	// 测试认证是否有效
	testClient := &http.Client{
		Timeout: 5 * time.Second,
	}
	
	// 获取 AWS 注册表主机
	registryHost, err := constants.GetAWSRegistryHost()
	if err != nil {
		log.Printf("[ERROR] Failed to get AWS registry host: %v", err)
	} else {
		testReq, _ := http.NewRequest("GET", fmt.Sprintf("https://%s/v2/", registryHost), nil)
		testReq.Header.Set("Authorization", fmt.Sprintf("Basic %s", token.DockerToken))
		testResp, testErr := testClient.Do(testReq)
		if testErr != nil {
			log.Printf("[ERROR] AWS ECR Auth Test - Failed to connect: %v", testErr)
		} else {
			defer testResp.Body.Close()
			log.Printf("[INFO] AWS ECR Auth Test - Status: %d", testResp.StatusCode)
			if testResp.StatusCode == http.StatusOK {
				log.Printf("[INFO] AWS ECR Auth Test - Basic auth successful")
			} else if testResp.StatusCode == http.StatusUnauthorized {
				log.Printf("[ERROR] AWS ECR Auth Test - Basic auth failed (Unauthorized)")
				respBody, _ := io.ReadAll(testResp.Body)
				log.Printf("[ERROR] AWS ECR Auth Test - Response: %s", string(respBody))
			} else {
				log.Printf("[WARN] AWS ECR Auth Test - Unexpected status code")
				respBody, _ := io.ReadAll(testResp.Body)
				log.Printf("[WARN] AWS ECR Auth Test - Response: %s", string(respBody))
			}
		}
	}
	
	// 客户端请求路径前缀
	repoPrefix := "/v2/e2b/custom-envs/"
	
	// 对于 AWS ECR，使用 base_repo_name 作为基础仓库名
	baseRepo := strings.Trim(constants.AWSECRRepository, "/")
	
	// 设置真实的仓库前缀，包含 templateID
	realRepoPrefix := fmt.Sprintf("/v2/%s/%s/", baseRepo, templateID)
	
	// 如果路径不是以客户端仓库前缀开头，拒绝访问
	if !strings.HasPrefix(path, repoPrefix) {
		log.Printf("[ERROR] No matching route found for path: %s", path)
		w.WriteHeader(http.StatusForbidden)
		return
	}
	
	// 提取路径中的模板 ID
	pathInRepo := strings.TrimPrefix(path, repoPrefix)
	templateWithBuildID := strings.Split(strings.Split(pathInRepo, "/")[0], ":")
	
	// 如果路径中的模板 ID 与令牌中的不同，拒绝访问
	if templateWithBuildID[0] != templateID {
		log.Printf("[ERROR] Access denied: path template ID %s doesn't match token template ID %s", 
			templateWithBuildID[0], templateID)
		w.WriteHeader(http.StatusForbidden)
		return
	}
	
	// 替换路径前缀，确保不会重复 templateID
	newPath := strings.Replace(req.URL.Path, 
							 fmt.Sprintf("%s%s", repoPrefix, templateID), 
							 realRepoPrefix, 
							 1)
	
	// 移除任何双斜杠
	newPath = strings.ReplaceAll(newPath, "//", "/")
	req.URL.Path = newPath
	
	log.Printf("[DEBUG] AWS Proxy - Converted path: %s", req.URL.Path)
	
	// 代理请求
	a.ServeHTTP(w, req)
}
